$date
	Sat Dec 19 20:10:26 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module cpu_tb $end
$var wire 32 ! mem_data_in [31:0] $end
$var wire 1 " mem_wen $end
$var wire 1 # mem_ren $end
$var wire 32 $ mem_data_out [31:0] $end
$var wire 32 % mem_addr [31:0] $end
$var reg 1 & clk $end
$var reg 1 ' rst $end
$scope module cpu $end
$var wire 1 & clk $end
$var wire 32 ( data_out [31:0] $end
$var wire 1 # mem_ren $end
$var wire 1 " mem_wen $end
$var wire 5 ) rd2_addr [4:0] $end
$var wire 32 * rd2_data [31:0] $end
$var wire 1 ' rst $end
$var wire 32 + rd1_data [31:0] $end
$var wire 5 , rd1_addr [4:0] $end
$var wire 32 - r2_data [31:0] $end
$var wire 5 . r2_addr [4:0] $end
$var wire 32 / r1_data [31:0] $end
$var wire 5 0 r1_addr [4:0] $end
$var wire 32 1 fetch_pc [31:0] $end
$var wire 32 2 fetch_ir [31:0] $end
$var wire 1 3 fetch $end
$var wire 1 4 execute $end
$var wire 5 5 decode_rd [4:0] $end
$var wire 7 6 decode_opcode [6:0] $end
$var wire 32 7 decode_op2 [31:0] $end
$var wire 32 8 decode_op1 [31:0] $end
$var wire 13 9 decode_offset [12:0] $end
$var wire 7 : decode_funct7 [6:0] $end
$var wire 3 ; decode_funct3 [2:0] $end
$var wire 1 < decode $end
$var wire 32 = data_in [31:0] $end
$var wire 32 > addr [31:0] $end
$var reg 3 ? next_state [2:0] $end
$var reg 3 @ state [2:0] $end
$scope module instr_decode $end
$var wire 1 < clk $end
$var wire 1 ' rst $end
$var wire 1 A rs2 $end
$var wire 1 B rs1 $end
$var wire 5 C rd [4:0] $end
$var wire 32 D r2_data [31:0] $end
$var wire 32 E r1_data [31:0] $end
$var wire 7 F opcode [6:0] $end
$var wire 32 G ir_in [31:0] $end
$var wire 7 H funct7 [6:0] $end
$var wire 3 I funct3 [2:0] $end
$var reg 32 J ir [31:0] $end
$var reg 13 K offset [12:0] $end
$var reg 32 L op1 [31:0] $end
$var reg 32 M op2 [31:0] $end
$var reg 5 N r1_addr [4:0] $end
$var reg 5 O r2_addr [4:0] $end
$upscope $end
$scope module instr_exec $end
$var wire 1 4 clk $end
$var wire 3 P funct3 [2:0] $end
$var wire 7 Q funct7 [6:0] $end
$var wire 13 R offset [12:0] $end
$var wire 32 S op1 [31:0] $end
$var wire 32 T op2 [31:0] $end
$var wire 7 U opcode [6:0] $end
$var wire 5 V rd [4:0] $end
$var wire 1 ' rst $end
$var wire 32 W pc [31:0] $end
$var reg 32 X mem_addr [31:0] $end
$var reg 1 Y mem_ren $end
$var reg 1 Z mem_wen $end
$var reg 5 [ reg_addr [4:0] $end
$var reg 32 \ reg_data [31:0] $end
$upscope $end
$scope module instr_fetch $end
$var wire 1 3 clk $end
$var wire 32 ] ir [31:0] $end
$var wire 32 ^ pc_data [31:0] $end
$var wire 1 _ pc_set $end
$var wire 1 ' rst $end
$var wire 32 ` mem_data [31:0] $end
$var reg 32 a mem_addr [31:0] $end
$var reg 32 b pc [31:0] $end
$upscope $end
$scope module registers $end
$var wire 1 & clk $end
$var wire 5 c r1_addr [4:0] $end
$var wire 5 d r2_addr [4:0] $end
$var wire 5 e rd1_addr [4:0] $end
$var wire 32 f rd1_data [31:0] $end
$var wire 5 g rd2_addr [4:0] $end
$var wire 32 h rd2_data [31:0] $end
$var wire 1 ' rst $end
$var reg 7 i i [6:0] $end
$var reg 32 j r1_data [31:0] $end
$var reg 32 k r2_data [31:0] $end
$upscope $end
$upscope $end
$scope module mem $end
$var wire 32 l addr [31:0] $end
$var wire 1 & clk $end
$var wire 32 m data_in [31:0] $end
$var wire 1 # mem_ren $end
$var wire 1 " mem_wen $end
$var reg 32 n data_out [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx n
b0 m
bx l
bx k
bx j
b100000 i
bz h
bz g
bx f
b0 e
bx d
bx c
b0 b
bx a
bx `
0_
b0 ^
bx ]
bx \
b0 [
xZ
xY
bx X
b0 W
b0 V
b0 U
b0 T
b0 S
b0 R
b0 Q
b0 P
bx O
bx N
b0 M
b0 L
b0 K
b0 J
b0 I
b0 H
bx G
b0 F
bx E
bx D
b0 C
0B
0A
b0 @
b1 ?
bx >
bx =
0<
b0 ;
b0 :
b0 9
b0 8
b0 7
b0 6
b0 5
04
03
bx 2
b0 1
bx 0
bx /
bx .
bx -
b0 ,
bx +
bz *
bz )
b0 (
1'
0&
bx %
bx $
0#
0"
b0 !
$end
#50
b100000 i
1&
#75
0'
#100
0&
#150
b10100000000000010010011 2
b10100000000000010010011 G
b10100000000000010010011 ]
b10100000000000010010011 $
b10100000000000010010011 =
b10100000000000010010011 `
b10100000000000010010011 n
b10 ?
b100 1
b100 W
b100 b
b0 %
b0 >
b0 a
b0 l
1#
13
b1 @
1&
#200
0&
#250
b0 /
b0 E
b0 j
b101 7
b101 M
b101 T
b0 8
b0 L
b0 S
b0 0
b0 N
b0 c
1A
b10011 6
b10011 F
b10011 U
b1 5
b1 C
b1 V
b11 ?
b10100000000000010010011 J
0#
03
1<
b10 @
1&
#300
0&
#350
b1 ?
b101 +
b101 \
b101 f
b1 ,
b1 [
b1 e
0<
14
b11 @
1&
#400
0&
#450
b10000001000000100010011 2
b10000001000000100010011 G
b10000001000000100010011 ]
b10000001000000100010011 $
b10000001000000100010011 =
b10000001000000100010011 `
b10000001000000100010011 n
b10 ?
b1000 1
b1000 W
b1000 b
b100 %
b100 >
b100 a
b100 l
1#
13
04
b1 @
1&
#500
0&
#550
b101 8
b101 L
b101 S
b101 /
b101 E
b101 j
b1 0
b1 N
b1 c
b100 7
b100 M
b100 T
1B
0A
b10 5
b10 C
b10 V
b11 ?
b10000001000000100010011 J
0#
03
1<
b10 @
1&
#600
0&
#650
b1 ?
b1001 +
b1001 \
b1001 f
b10 ,
b10 [
b10 e
0<
14
b11 @
1&
#700
0&
#750
bx 2
bx G
bx ]
bx $
bx =
bx `
bx n
b10 ?
b1100 1
b1100 W
b1100 b
b1000 %
b1000 >
b1000 a
b1000 l
1#
13
04
b1 @
1&
#800
0&
#850
xB
xA
bx 6
bx F
bx U
bx 5
bx C
bx V
bx ;
bx I
bx P
bx :
bx H
bx Q
b11 ?
bx J
0#
03
1<
b10 @
1&
#900
0&
#950
b1 ?
0<
14
b11 @
1&
#1000
0&
